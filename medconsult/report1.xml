<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="4" time="5.652" timestamp="2026-02-22T13:42:29.027900-05:00" hostname="AliAmjad"><testcase classname="tests.test_phase1" name="test_model_loads" time="0.388"><failure message="OSError: You are trying to access a gated repo.&#10;Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.&#10;401 Client Error. (Request ID: Root=1-699b4e18-33c7e2807867df8106d49f9b;9452f248-89c9-4c7b-968f-2cf6f0ac6d3b)&#10;&#10;Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.&#10;Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.">response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
&gt;           response.raise_for_status()

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Response [401 Unauthorized]&gt;

    def raise_for_status(self) -&gt; Response:
        """
        Raise the `HTTPStatusError` if one occurred.
        """
        request = self._request
        if request is None:
            raise RuntimeError(
                "Cannot call `raise_for_status` as the request "
                "instance has not been set on this response."
            )
    
        if self.is_success:
            return self
    
        if self.has_redirect_location:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "Redirect location: '{0.headers[location]}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
        else:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
    
        status_class = self.status_code // 100
        error_types = {
            1: "Informational response",
            3: "Redirect response",
            4: "Client error",
            5: "Server error",
        }
        error_type = error_types.get(status_class, "Invalid status code")
        message = message.format(self, error_type=error_type)
&gt;       raise HTTPStatusError(message, request=request, response=self)
E       httpx.HTTPStatusError: Client error '401 Unauthorized' for url 'https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json'
E       For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\httpx\_models.py:829: HTTPStatusError

The above exception was the direct cause of the following exception:

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
&gt;               hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1032: in hf_hub_download
    return _hf_hub_download_to_cache_dir(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1183: in _hf_hub_download_to_cache_dir
    _raise_on_head_call_error(head_call_error, force_download, local_files_only)
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1812: in _raise_on_head_call_error
    raise head_call_error
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1699: in _get_metadata_or_catch_error
    metadata = get_hf_file_metadata(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1622: in get_hf_file_metadata
    response = _httpx_follow_relative_redirects(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:309: in _httpx_follow_relative_redirects
    hf_raise_for_status(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            if response.status_code // 100 == 3:
                return  # Do not raise on redirects to stay consistent with `requests`
    
            error_code = response.headers.get("X-Error-Code")
            error_message = response.headers.get("X-Error-Message")
    
            if error_code == "RevisionNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Revision Not Found for url: {response.url}."
                raise _format(RevisionNotFoundError, message, response) from e
    
            elif error_code == "EntryNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Entry Not Found for url: {response.url}."
                raise _format(RemoteEntryNotFoundError, message, response) from e
    
            elif error_code == "GatedRepo":
                message = (
                    f"{response.status_code} Client Error." + "\n\n" + f"Cannot access gated repo for url {response.url}."
                )
&gt;               raise _format(GatedRepoError, message, response) from e
E               huggingface_hub.errors.GatedRepoError: 401 Client Error. (Request ID: Root=1-699b4e18-33c7e2807867df8106d49f9b;9452f248-89c9-4c7b-968f-2cf6f0ac6d3b)
E               
E               Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E               Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:677: GatedRepoError

The above exception was the direct cause of the following exception:

    def test_model_loads():
        """TEST 1 - Model loads successfully"""
        manager = ModelManager()
&gt;       model, processor = manager.load_model()
                           ^^^^^^^^^^^^^^^^^^^^

tests\test_phase1.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
model\model_manager.py:44: in load_model
    self.processor = AutoProcessor.from_pretrained(model_id, token=token)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\processing_auto.py:366: in from_pretrained
    config = AutoConfig.from_pretrained(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\configuration_auto.py:1403: in from_pretrained
    config_dict, unused_kwargs = PreTrainedConfig.get_config_dict(pretrained_model_name_or_path, **kwargs)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:572: in get_config_dict
    config_dict, kwargs = cls._get_config_dict(pretrained_model_name_or_path, **kwargs)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:627: in _get_config_dict
    resolved_config_file = cached_file(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:276: in cached_file
    file = cached_files(path_or_repo_id=path_or_repo_id, filenames=[filename], **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
                hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
            else:
                snapshot_download(
                    path_or_repo_id,
                    allow_patterns=full_filenames,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
    
        except Exception as e:
            # We cannot recover from them
            if isinstance(e, RepositoryNotFoundError) and not isinstance(e, GatedRepoError):
                raise OSError(
                    f"{path_or_repo_id} is not a local folder and is not a valid model identifier "
                    "listed on 'https://huggingface.co/models'\nIf this is a private repository, make sure to pass a token "
                    "having permission to this repo either by logging in with `hf auth login` or by passing "
                    "`token=&lt;your_token&gt;`"
                ) from e
            elif isinstance(e, RevisionNotFoundError):
                raise OSError(
                    f"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists "
                    "for this model name. Check the model page at "
                    f"'https://huggingface.co/{path_or_repo_id}' for available revisions."
                ) from e
            elif isinstance(e, PermissionError):
                raise OSError(
                    f"PermissionError at {e.filename} when downloading {path_or_repo_id}. "
                    "Check cache directory permissions. Common causes: 1) another user is downloading the same model (please wait); "
                    "2) a previous download was canceled and the lock file needs manual removal."
                ) from e
            elif isinstance(e, ValueError):
                raise OSError(f"{e}") from e
    
            # Now we try to recover if we can find all files correctly in the cache
            resolved_files = [
                _get_cache_file_to_return(path_or_repo_id, filename, cache_dir, revision, repo_type)
                for filename in full_filenames
            ]
            if all(file is not None for file in resolved_files):
                return resolved_files
    
            # Raise based on the flags. Note that we will raise for missing entries at the very end, even when
            # not entering this Except block, as it may also happen when `snapshot_download` does not raise
            if isinstance(e, GatedRepoError):
                if not _raise_exceptions_for_gated_repo:
                    return None
&gt;               raise OSError(
                    "You are trying to access a gated repo.\nMake sure to have access to it at "
                    f"https://huggingface.co/{path_or_repo_id}.\n{str(e)}"
E                   OSError: You are trying to access a gated repo.
E                   Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.
E                   401 Client Error. (Request ID: Root=1-699b4e18-33c7e2807867df8106d49f9b;9452f248-89c9-4c7b-968f-2cf6f0ac6d3b)
E                   
E                   Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E                   Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:483: OSError</failure></testcase><testcase classname="tests.test_phase1" name="test_text_generation" time="0.145"><failure message="OSError: You are trying to access a gated repo.&#10;Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.&#10;401 Client Error. (Request ID: Root=1-699b4e19-44790b0149ff2df2719e090d;89e74e20-517f-434f-aa31-1c24b0c47b9d)&#10;&#10;Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.&#10;Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.">response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
&gt;           response.raise_for_status()

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Response [401 Unauthorized]&gt;

    def raise_for_status(self) -&gt; Response:
        """
        Raise the `HTTPStatusError` if one occurred.
        """
        request = self._request
        if request is None:
            raise RuntimeError(
                "Cannot call `raise_for_status` as the request "
                "instance has not been set on this response."
            )
    
        if self.is_success:
            return self
    
        if self.has_redirect_location:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "Redirect location: '{0.headers[location]}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
        else:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
    
        status_class = self.status_code // 100
        error_types = {
            1: "Informational response",
            3: "Redirect response",
            4: "Client error",
            5: "Server error",
        }
        error_type = error_types.get(status_class, "Invalid status code")
        message = message.format(self, error_type=error_type)
&gt;       raise HTTPStatusError(message, request=request, response=self)
E       httpx.HTTPStatusError: Client error '401 Unauthorized' for url 'https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json'
E       For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\httpx\_models.py:829: HTTPStatusError

The above exception was the direct cause of the following exception:

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
&gt;               hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1032: in hf_hub_download
    return _hf_hub_download_to_cache_dir(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1183: in _hf_hub_download_to_cache_dir
    _raise_on_head_call_error(head_call_error, force_download, local_files_only)
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1812: in _raise_on_head_call_error
    raise head_call_error
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1699: in _get_metadata_or_catch_error
    metadata = get_hf_file_metadata(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1622: in get_hf_file_metadata
    response = _httpx_follow_relative_redirects(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:309: in _httpx_follow_relative_redirects
    hf_raise_for_status(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            if response.status_code // 100 == 3:
                return  # Do not raise on redirects to stay consistent with `requests`
    
            error_code = response.headers.get("X-Error-Code")
            error_message = response.headers.get("X-Error-Message")
    
            if error_code == "RevisionNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Revision Not Found for url: {response.url}."
                raise _format(RevisionNotFoundError, message, response) from e
    
            elif error_code == "EntryNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Entry Not Found for url: {response.url}."
                raise _format(RemoteEntryNotFoundError, message, response) from e
    
            elif error_code == "GatedRepo":
                message = (
                    f"{response.status_code} Client Error." + "\n\n" + f"Cannot access gated repo for url {response.url}."
                )
&gt;               raise _format(GatedRepoError, message, response) from e
E               huggingface_hub.errors.GatedRepoError: 401 Client Error. (Request ID: Root=1-699b4e19-44790b0149ff2df2719e090d;89e74e20-517f-434f-aa31-1c24b0c47b9d)
E               
E               Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E               Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:677: GatedRepoError

The above exception was the direct cause of the following exception:

    def test_text_generation():
        """TEST 2 - Text-only generation works"""
        manager = ModelManager()
        system_prompt = "You are a helpful medical assistant."
        user_message = "What does hemoglobin measure in a blood test? Answer in exactly 2 sentences."
    
&gt;       response = manager.generate_response(system_prompt, user_message)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_phase1.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
model\model_manager.py:54: in generate_response
    self.load_model()
model\model_manager.py:44: in load_model
    self.processor = AutoProcessor.from_pretrained(model_id, token=token)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\processing_auto.py:366: in from_pretrained
    config = AutoConfig.from_pretrained(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\configuration_auto.py:1403: in from_pretrained
    config_dict, unused_kwargs = PreTrainedConfig.get_config_dict(pretrained_model_name_or_path, **kwargs)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:572: in get_config_dict
    config_dict, kwargs = cls._get_config_dict(pretrained_model_name_or_path, **kwargs)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:627: in _get_config_dict
    resolved_config_file = cached_file(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:276: in cached_file
    file = cached_files(path_or_repo_id=path_or_repo_id, filenames=[filename], **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
                hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
            else:
                snapshot_download(
                    path_or_repo_id,
                    allow_patterns=full_filenames,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
    
        except Exception as e:
            # We cannot recover from them
            if isinstance(e, RepositoryNotFoundError) and not isinstance(e, GatedRepoError):
                raise OSError(
                    f"{path_or_repo_id} is not a local folder and is not a valid model identifier "
                    "listed on 'https://huggingface.co/models'\nIf this is a private repository, make sure to pass a token "
                    "having permission to this repo either by logging in with `hf auth login` or by passing "
                    "`token=&lt;your_token&gt;`"
                ) from e
            elif isinstance(e, RevisionNotFoundError):
                raise OSError(
                    f"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists "
                    "for this model name. Check the model page at "
                    f"'https://huggingface.co/{path_or_repo_id}' for available revisions."
                ) from e
            elif isinstance(e, PermissionError):
                raise OSError(
                    f"PermissionError at {e.filename} when downloading {path_or_repo_id}. "
                    "Check cache directory permissions. Common causes: 1) another user is downloading the same model (please wait); "
                    "2) a previous download was canceled and the lock file needs manual removal."
                ) from e
            elif isinstance(e, ValueError):
                raise OSError(f"{e}") from e
    
            # Now we try to recover if we can find all files correctly in the cache
            resolved_files = [
                _get_cache_file_to_return(path_or_repo_id, filename, cache_dir, revision, repo_type)
                for filename in full_filenames
            ]
            if all(file is not None for file in resolved_files):
                return resolved_files
    
            # Raise based on the flags. Note that we will raise for missing entries at the very end, even when
            # not entering this Except block, as it may also happen when `snapshot_download` does not raise
            if isinstance(e, GatedRepoError):
                if not _raise_exceptions_for_gated_repo:
                    return None
&gt;               raise OSError(
                    "You are trying to access a gated repo.\nMake sure to have access to it at "
                    f"https://huggingface.co/{path_or_repo_id}.\n{str(e)}"
E                   OSError: You are trying to access a gated repo.
E                   Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.
E                   401 Client Error. (Request ID: Root=1-699b4e19-44790b0149ff2df2719e090d;89e74e20-517f-434f-aa31-1c24b0c47b9d)
E                   
E                   Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E                   Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:483: OSError</failure></testcase><testcase classname="tests.test_phase1" name="test_follows_system_prompt" time="0.144"><failure message="OSError: You are trying to access a gated repo.&#10;Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.&#10;401 Client Error. (Request ID: Root=1-699b4e19-67c286d7219cdcfb35d0d9d7;ba1a968d-c2e1-4eb2-9bb4-e137f58d3586)&#10;&#10;Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.&#10;Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.">response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
&gt;           response.raise_for_status()

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Response [401 Unauthorized]&gt;

    def raise_for_status(self) -&gt; Response:
        """
        Raise the `HTTPStatusError` if one occurred.
        """
        request = self._request
        if request is None:
            raise RuntimeError(
                "Cannot call `raise_for_status` as the request "
                "instance has not been set on this response."
            )
    
        if self.is_success:
            return self
    
        if self.has_redirect_location:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "Redirect location: '{0.headers[location]}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
        else:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
    
        status_class = self.status_code // 100
        error_types = {
            1: "Informational response",
            3: "Redirect response",
            4: "Client error",
            5: "Server error",
        }
        error_type = error_types.get(status_class, "Invalid status code")
        message = message.format(self, error_type=error_type)
&gt;       raise HTTPStatusError(message, request=request, response=self)
E       httpx.HTTPStatusError: Client error '401 Unauthorized' for url 'https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json'
E       For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\httpx\_models.py:829: HTTPStatusError

The above exception was the direct cause of the following exception:

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
&gt;               hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1032: in hf_hub_download
    return _hf_hub_download_to_cache_dir(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1183: in _hf_hub_download_to_cache_dir
    _raise_on_head_call_error(head_call_error, force_download, local_files_only)
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1812: in _raise_on_head_call_error
    raise head_call_error
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1699: in _get_metadata_or_catch_error
    metadata = get_hf_file_metadata(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1622: in get_hf_file_metadata
    response = _httpx_follow_relative_redirects(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:309: in _httpx_follow_relative_redirects
    hf_raise_for_status(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            if response.status_code // 100 == 3:
                return  # Do not raise on redirects to stay consistent with `requests`
    
            error_code = response.headers.get("X-Error-Code")
            error_message = response.headers.get("X-Error-Message")
    
            if error_code == "RevisionNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Revision Not Found for url: {response.url}."
                raise _format(RevisionNotFoundError, message, response) from e
    
            elif error_code == "EntryNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Entry Not Found for url: {response.url}."
                raise _format(RemoteEntryNotFoundError, message, response) from e
    
            elif error_code == "GatedRepo":
                message = (
                    f"{response.status_code} Client Error." + "\n\n" + f"Cannot access gated repo for url {response.url}."
                )
&gt;               raise _format(GatedRepoError, message, response) from e
E               huggingface_hub.errors.GatedRepoError: 401 Client Error. (Request ID: Root=1-699b4e19-67c286d7219cdcfb35d0d9d7;ba1a968d-c2e1-4eb2-9bb4-e137f58d3586)
E               
E               Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E               Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:677: GatedRepoError

The above exception was the direct cause of the following exception:

    def test_follows_system_prompt():
        """TEST 3 - Response follows system prompt instructions"""
        manager = ModelManager()
        system_prompt = "You are a medical data extractor. When given medical text, respond ONLY with a JSON object listing each finding. No other text."
        user_message = "Patient has elevated blood pressure at 162/94 and heart rate of 96."
    
&gt;       response = manager.generate_response(system_prompt, user_message)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_phase1.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
model\model_manager.py:54: in generate_response
    self.load_model()
model\model_manager.py:44: in load_model
    self.processor = AutoProcessor.from_pretrained(model_id, token=token)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\processing_auto.py:366: in from_pretrained
    config = AutoConfig.from_pretrained(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\configuration_auto.py:1403: in from_pretrained
    config_dict, unused_kwargs = PreTrainedConfig.get_config_dict(pretrained_model_name_or_path, **kwargs)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:572: in get_config_dict
    config_dict, kwargs = cls._get_config_dict(pretrained_model_name_or_path, **kwargs)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:627: in _get_config_dict
    resolved_config_file = cached_file(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:276: in cached_file
    file = cached_files(path_or_repo_id=path_or_repo_id, filenames=[filename], **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
                hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
            else:
                snapshot_download(
                    path_or_repo_id,
                    allow_patterns=full_filenames,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
    
        except Exception as e:
            # We cannot recover from them
            if isinstance(e, RepositoryNotFoundError) and not isinstance(e, GatedRepoError):
                raise OSError(
                    f"{path_or_repo_id} is not a local folder and is not a valid model identifier "
                    "listed on 'https://huggingface.co/models'\nIf this is a private repository, make sure to pass a token "
                    "having permission to this repo either by logging in with `hf auth login` or by passing "
                    "`token=&lt;your_token&gt;`"
                ) from e
            elif isinstance(e, RevisionNotFoundError):
                raise OSError(
                    f"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists "
                    "for this model name. Check the model page at "
                    f"'https://huggingface.co/{path_or_repo_id}' for available revisions."
                ) from e
            elif isinstance(e, PermissionError):
                raise OSError(
                    f"PermissionError at {e.filename} when downloading {path_or_repo_id}. "
                    "Check cache directory permissions. Common causes: 1) another user is downloading the same model (please wait); "
                    "2) a previous download was canceled and the lock file needs manual removal."
                ) from e
            elif isinstance(e, ValueError):
                raise OSError(f"{e}") from e
    
            # Now we try to recover if we can find all files correctly in the cache
            resolved_files = [
                _get_cache_file_to_return(path_or_repo_id, filename, cache_dir, revision, repo_type)
                for filename in full_filenames
            ]
            if all(file is not None for file in resolved_files):
                return resolved_files
    
            # Raise based on the flags. Note that we will raise for missing entries at the very end, even when
            # not entering this Except block, as it may also happen when `snapshot_download` does not raise
            if isinstance(e, GatedRepoError):
                if not _raise_exceptions_for_gated_repo:
                    return None
&gt;               raise OSError(
                    "You are trying to access a gated repo.\nMake sure to have access to it at "
                    f"https://huggingface.co/{path_or_repo_id}.\n{str(e)}"
E                   OSError: You are trying to access a gated repo.
E                   Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.
E                   401 Client Error. (Request ID: Root=1-699b4e19-67c286d7219cdcfb35d0d9d7;ba1a968d-c2e1-4eb2-9bb4-e137f58d3586)
E                   
E                   Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E                   Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:483: OSError</failure></testcase><testcase classname="tests.test_phase1" name="test_different_prompts_different_outputs" time="0.139"><failure message="OSError: You are trying to access a gated repo.&#10;Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.&#10;401 Client Error. (Request ID: Root=1-699b4e19-6f88851f433ada6c32215bd2;d366233c-4990-47f9-a67b-445ea60eeba8)&#10;&#10;Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.&#10;Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.">response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
&gt;           response.raise_for_status()

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Response [401 Unauthorized]&gt;

    def raise_for_status(self) -&gt; Response:
        """
        Raise the `HTTPStatusError` if one occurred.
        """
        request = self._request
        if request is None:
            raise RuntimeError(
                "Cannot call `raise_for_status` as the request "
                "instance has not been set on this response."
            )
    
        if self.is_success:
            return self
    
        if self.has_redirect_location:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "Redirect location: '{0.headers[location]}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
        else:
            message = (
                "{error_type} '{0.status_code} {0.reason_phrase}' for url '{0.url}'\n"
                "For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/{0.status_code}"
            )
    
        status_class = self.status_code // 100
        error_types = {
            1: "Informational response",
            3: "Redirect response",
            4: "Client error",
            5: "Server error",
        }
        error_type = error_types.get(status_class, "Invalid status code")
        message = message.format(self, error_type=error_type)
&gt;       raise HTTPStatusError(message, request=request, response=self)
E       httpx.HTTPStatusError: Client error '401 Unauthorized' for url 'https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json'
E       For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\httpx\_models.py:829: HTTPStatusError

The above exception was the direct cause of the following exception:

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
&gt;               hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1032: in hf_hub_download
    return _hf_hub_download_to_cache_dir(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1183: in _hf_hub_download_to_cache_dir
    _raise_on_head_call_error(head_call_error, force_download, local_files_only)
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1812: in _raise_on_head_call_error
    raise head_call_error
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1699: in _get_metadata_or_catch_error
    metadata = get_hf_file_metadata(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_validators.py:89: in _inner_fn
    return fn(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:1622: in get_hf_file_metadata
    response = _httpx_follow_relative_redirects(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\file_download.py:309: in _httpx_follow_relative_redirects
    hf_raise_for_status(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

response = &lt;Response [401 Unauthorized]&gt;, endpoint_name = None

    def hf_raise_for_status(response: httpx.Response, endpoint_name: Optional[str] = None) -&gt; None:
        """
        Internal version of `response.raise_for_status()` that will refine a potential HTTPError.
        Raised exception will be an instance of [`~errors.HfHubHTTPError`].
    
        This helper is meant to be the unique method to raise_for_status when making a call to the Hugging Face Hub.
    
        Args:
            response (`Response`):
                Response from the server.
            endpoint_name (`str`, *optional*):
                Name of the endpoint that has been called. If provided, the error message will be more complete.
    
        &gt; [!WARNING]
        &gt; Raises when the request has failed:
        &gt;
        &gt;     - [`~utils.RepositoryNotFoundError`]
        &gt;         If the repository to download from cannot be found. This may be because it
        &gt;         doesn't exist, because `repo_type` is not set correctly, or because the repo
        &gt;         is `private` and you do not have access.
        &gt;     - [`~utils.GatedRepoError`]
        &gt;         If the repository exists but is gated and the user is not on the authorized
        &gt;         list.
        &gt;     - [`~utils.RevisionNotFoundError`]
        &gt;         If the repository exists but the revision couldn't be found.
        &gt;     - [`~utils.EntryNotFoundError`]
        &gt;         If the repository exists but the entry (e.g. the requested file) couldn't be
        &gt;         find.
        &gt;     - [`~utils.BadRequestError`]
        &gt;         If request failed with a HTTP 400 BadRequest error.
        &gt;     - [`~utils.HfHubHTTPError`]
        &gt;         If request failed for a reason not listed above.
        """
        try:
            _warn_on_warning_headers(response)
        except Exception:
            # Never raise on warning parsing
            logger.debug("Failed to parse warning headers", exc_info=True)
    
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            if response.status_code // 100 == 3:
                return  # Do not raise on redirects to stay consistent with `requests`
    
            error_code = response.headers.get("X-Error-Code")
            error_message = response.headers.get("X-Error-Message")
    
            if error_code == "RevisionNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Revision Not Found for url: {response.url}."
                raise _format(RevisionNotFoundError, message, response) from e
    
            elif error_code == "EntryNotFound":
                message = f"{response.status_code} Client Error." + "\n\n" + f"Entry Not Found for url: {response.url}."
                raise _format(RemoteEntryNotFoundError, message, response) from e
    
            elif error_code == "GatedRepo":
                message = (
                    f"{response.status_code} Client Error." + "\n\n" + f"Cannot access gated repo for url {response.url}."
                )
&gt;               raise _format(GatedRepoError, message, response) from e
E               huggingface_hub.errors.GatedRepoError: 401 Client Error. (Request ID: Root=1-699b4e19-6f88851f433ada6c32215bd2;d366233c-4990-47f9-a67b-445ea60eeba8)
E               
E               Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E               Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\huggingface_hub\utils\_http.py:677: GatedRepoError

The above exception was the direct cause of the following exception:

    def test_different_prompts_different_outputs():
        """TEST 4 - Model produces different outputs for different system prompts"""
        manager = ModelManager()
        user_message = "The patient's WBC is 12.8"
    
        prompt_A = "You extract medical facts. List only the facts, no interpretation."
&gt;       response_A = manager.generate_response(prompt_A, user_message)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_phase1.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
model\model_manager.py:54: in generate_response
    self.load_model()
model\model_manager.py:44: in load_model
    self.processor = AutoProcessor.from_pretrained(model_id, token=token)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\processing_auto.py:366: in from_pretrained
    config = AutoConfig.from_pretrained(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\models\auto\configuration_auto.py:1403: in from_pretrained
    config_dict, unused_kwargs = PreTrainedConfig.get_config_dict(pretrained_model_name_or_path, **kwargs)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:572: in get_config_dict
    config_dict, kwargs = cls._get_config_dict(pretrained_model_name_or_path, **kwargs)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\configuration_utils.py:627: in _get_config_dict
    resolved_config_file = cached_file(
C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:276: in cached_file
    file = cached_files(path_or_repo_id=path_or_repo_id, filenames=[filename], **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path_or_repo_id = 'google/medgemma-1.5-4b-it', filenames = ['config.json']
cache_dir = 'C:\\Users\\aliam\\.cache\\huggingface\\hub', force_download = False
proxies = None, token = None, revision = None, local_files_only = False
subfolder = '', repo_type = None
user_agent = 'transformers/5.2.0; python/3.14.0; session_id/1054882dfed2419d935d2fea76c9217a; torch/2.10.0; file_type/config; from_auto_class/True'
_raise_exceptions_for_gated_repo = True
_raise_exceptions_for_missing_entries = True
_raise_exceptions_for_connection_errors = True, _commit_hash = None
deprecated_kwargs = {}, full_filenames = ['config.json'], existing_files = []
filename = 'config.json', file_counter = 0

    def cached_files(
        path_or_repo_id: str | os.PathLike,
        filenames: list[str],
        cache_dir: str | os.PathLike | None = None,
        force_download: bool = False,
        proxies: dict[str, str] | None = None,
        token: bool | str | None = None,
        revision: str | None = None,
        local_files_only: bool = False,
        subfolder: str = "",
        repo_type: str | None = None,
        user_agent: str | dict[str, str] | None = None,
        _raise_exceptions_for_gated_repo: bool = True,
        _raise_exceptions_for_missing_entries: bool = True,
        _raise_exceptions_for_connection_errors: bool = True,
        _commit_hash: str | None = None,
        **deprecated_kwargs,
    ) -&gt; str | None:
        """
        Tries to locate several files in a local folder and repo, downloads and cache them if necessary.
    
        Args:
            path_or_repo_id (`str` or `os.PathLike`):
                This can be either:
                - a string, the *model id* of a model repo on huggingface.co.
                - a path to a *directory* potentially containing the file.
            filenames (`list[str]`):
                The name of all the files to locate in `path_or_repo`.
            cache_dir (`str` or `os.PathLike`, *optional*):
                Path to a directory in which a downloaded pretrained model configuration should be cached if the standard
                cache should not be used.
            force_download (`bool`, *optional*, defaults to `False`):
                Whether or not to force to (re-)download the configuration files and override the cached versions if they
                exist.
            proxies (`dict[str, str]`, *optional*):
                A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',
                'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.
            token (`str` or *bool*, *optional*):
                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated
                when running `hf auth login` (stored in `~/.huggingface`).
            revision (`str`, *optional*, defaults to `"main"`):
                The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
                git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any
                identifier allowed by git.
            local_files_only (`bool`, *optional*, defaults to `False`):
                If `True`, will only try to load the tokenizer configuration from local files.
            subfolder (`str`, *optional*, defaults to `""`):
                In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can
                specify the folder name here.
            repo_type (`str`, *optional*):
                Specify the repo type (useful when downloading from a space for instance).
    
        Private args:
            _raise_exceptions_for_gated_repo (`bool`):
                if False, do not raise an exception for gated repo error but return None.
            _raise_exceptions_for_missing_entries (`bool`):
                if False, do not raise an exception for missing entries but return None.
            _raise_exceptions_for_connection_errors (`bool`):
                if False, do not raise an exception for connection errors but return None.
            _commit_hash (`str`, *optional*):
                passed when we are chaining several calls to various files (e.g. when loading a tokenizer or
                a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.
    
        &lt;Tip&gt;
    
        Passing `token=True` is required when you want to use a private model.
    
        &lt;/Tip&gt;
    
        Returns:
            `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).
    
        Examples:
    
        ```python
        # Download a model weight from the Hub and cache it.
        model_weights_file = cached_file("google-bert/bert-base-uncased", "pytorch_model.bin")
        ```
        """
        if is_offline_mode() and not local_files_only:
            logger.info("Offline mode: forcing local_files_only=True")
            local_files_only = True
        if subfolder is None:
            subfolder = ""
    
        # Add folder to filenames
        full_filenames = [os.path.join(subfolder, file) for file in filenames]
    
        path_or_repo_id = str(path_or_repo_id)
        existing_files = []
        for filename in full_filenames:
            if os.path.isdir(path_or_repo_id):
                resolved_file = os.path.join(path_or_repo_id, filename)
                if not os.path.isfile(resolved_file):
                    if _raise_exceptions_for_missing_entries and filename != os.path.join(subfolder, "config.json"):
                        revision_ = "main" if revision is None else revision
                        raise OSError(
                            f"{path_or_repo_id} does not appear to have a file named {filename}. Checkout "
                            f"'https://huggingface.co/{path_or_repo_id}/tree/{revision_}' for available files."
                        )
                    else:
                        continue
                existing_files.append(resolved_file)
    
        if os.path.isdir(path_or_repo_id):
            return existing_files if existing_files else None
    
        if cache_dir is None:
            cache_dir = constants.HF_HUB_CACHE
        if isinstance(cache_dir, Path):
            cache_dir = str(cache_dir)
    
        existing_files = []
        file_counter = 0
        if _commit_hash is not None and not force_download:
            for filename in full_filenames:
                # If the file is cached under that commit hash, we return it directly.
                resolved_file = try_to_load_from_cache(
                    path_or_repo_id, filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type
                )
                if resolved_file is not None:
                    if resolved_file is not _CACHED_NO_EXIST:
                        file_counter += 1
                        existing_files.append(resolved_file)
                    elif not _raise_exceptions_for_missing_entries:
                        file_counter += 1
                    else:
                        raise OSError(f"Could not locate {filename} inside {path_or_repo_id}.")
    
        # Either all the files were found, or some were _CACHED_NO_EXIST but we do not raise for missing entries
        if file_counter == len(full_filenames):
            return existing_files if len(existing_files) &gt; 0 else None
    
        user_agent = http_user_agent(user_agent)
        # download the files if needed
        try:
            if len(full_filenames) == 1:
                # This is slightly better for only 1 file
                hf_hub_download(
                    path_or_repo_id,
                    filenames[0],
                    subfolder=None if len(subfolder) == 0 else subfolder,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
            else:
                snapshot_download(
                    path_or_repo_id,
                    allow_patterns=full_filenames,
                    repo_type=repo_type,
                    revision=revision,
                    cache_dir=cache_dir,
                    user_agent=user_agent,
                    force_download=force_download,
                    proxies=proxies,
                    token=token,
                    local_files_only=local_files_only,
                )
    
        except Exception as e:
            # We cannot recover from them
            if isinstance(e, RepositoryNotFoundError) and not isinstance(e, GatedRepoError):
                raise OSError(
                    f"{path_or_repo_id} is not a local folder and is not a valid model identifier "
                    "listed on 'https://huggingface.co/models'\nIf this is a private repository, make sure to pass a token "
                    "having permission to this repo either by logging in with `hf auth login` or by passing "
                    "`token=&lt;your_token&gt;`"
                ) from e
            elif isinstance(e, RevisionNotFoundError):
                raise OSError(
                    f"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists "
                    "for this model name. Check the model page at "
                    f"'https://huggingface.co/{path_or_repo_id}' for available revisions."
                ) from e
            elif isinstance(e, PermissionError):
                raise OSError(
                    f"PermissionError at {e.filename} when downloading {path_or_repo_id}. "
                    "Check cache directory permissions. Common causes: 1) another user is downloading the same model (please wait); "
                    "2) a previous download was canceled and the lock file needs manual removal."
                ) from e
            elif isinstance(e, ValueError):
                raise OSError(f"{e}") from e
    
            # Now we try to recover if we can find all files correctly in the cache
            resolved_files = [
                _get_cache_file_to_return(path_or_repo_id, filename, cache_dir, revision, repo_type)
                for filename in full_filenames
            ]
            if all(file is not None for file in resolved_files):
                return resolved_files
    
            # Raise based on the flags. Note that we will raise for missing entries at the very end, even when
            # not entering this Except block, as it may also happen when `snapshot_download` does not raise
            if isinstance(e, GatedRepoError):
                if not _raise_exceptions_for_gated_repo:
                    return None
&gt;               raise OSError(
                    "You are trying to access a gated repo.\nMake sure to have access to it at "
                    f"https://huggingface.co/{path_or_repo_id}.\n{str(e)}"
E                   OSError: You are trying to access a gated repo.
E                   Make sure to have access to it at https://huggingface.co/google/medgemma-1.5-4b-it.
E                   401 Client Error. (Request ID: Root=1-699b4e19-6f88851f433ada6c32215bd2;d366233c-4990-47f9-a67b-445ea60eeba8)
E                   
E                   Cannot access gated repo for url https://huggingface.co/google/medgemma-1.5-4b-it/resolve/main/config.json.
E                   Access to model google/medgemma-1.5-4b-it is restricted. You must have access to it and be authenticated to access it. Please log in.

C:\Users\aliam\AppData\Roaming\Python\Python314\site-packages\transformers\utils\hub.py:483: OSError</failure></testcase></testsuite></testsuites>